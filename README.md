# HolyTS - Drop in Replacement for Macros in other Languages.
HolyTypeScript written to write Source Code for other Holy Languages. Implements a TS => HolyC like Compiler. Gets mainly used as drop in replacement for Macros in other languages.

It is a omage to Terry and the message that he spread to the world even if he got not right understood which frustrated him maybe as much as it does me but i am a stronger person. Anyway This allows you to Write HolyC like C Code or any other Code but i use it Mainly for C and C++

HolyTS implements many concepts of other popular projects but in a opinionated way that i identified as beeing the most Easy to learn teach and use without additional quirks a main reason why this exists is that it is to much overhead to use other solutions that exist as you need to learn all the quirks. In fact it implements the Stealify Lang but renamed to HolyTS as omage and it also adds Typescript like Implementation concepts maybe it will at some point be a drop in replacement for typescripts nodejs implementation. 

## Supported Runtimes
- [ ] @stealify/b8g (Big Engine)
- [ ] NodeJS
- [ ] JustJS
- [ ] Partial<Cloudflare Workers> WinterCG Web


## Goals
- Opinions / Observations / Assumptions.
  - Learning Posix principels fundamentals is a must have and should be the entrance to coding at all learn ipc and pipes as also the process fork concepts
  - Learning Python
    - should be optional while is needed at present to convert existing tooling 
  - learning pearl 
    - should be optional while is needed at present to convert existing tooling eg kernel
  - learning c / makefile build tools
    - is essential for long term success as a coder as also become senior dev
  - learning c++ basics at last try to implement some stealify components even if you do not fully understand the code should be as easy as write some Typescript like code. 
  - tooling should exist to adopt and parse other languages into a unified ast that can then be modified to match target results or can even get exposed in multiple versions via overlayed data views. This then allows to treat code written in any language as Code Node and modify its behavior which allows to do essential unmatched control over the execution and results as also allows inverse of control as also instrumentation. Aka we can fix any code fast and consistent.
  - There should exist patterns to work with any kind of source code and integrate it into your project without much overhead
  - Incremental adoption in existing projects should be the most logical reasoning for every Source Code Owner or Maintainer.
    - If this is not reached we did fail badly at present we fail badly thats why i do all the stuff my self.


